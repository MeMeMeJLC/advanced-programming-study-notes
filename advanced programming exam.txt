advanced programming exam

question 2 - bad smells
*what is the bad smells
1. how do you know it is that bad smell, and how is it solved?
2. what does it look like?
3. how does removing it improve reusability?
4. what is the step by step to remove the bad smell?

	***bloaters***
*long method
1. how do you know it is that bad smell, and how is it solved?
	-method has more than 10 lines
	-can use EXTRACT METHOD (code fragment can be grouped together and put in a new method, replace the old code with a call to the new method)
	-if local vars too intertwined that you cant apply Extract Method then use REPLACE METHOD WITH METHOD OBJECT (transform the method into a separate method so that the local variables become fields of the class. then you can split the method into several methods wiithin the same class.) 
	-if complex conditional (switch) then decompose the complicated parts of the conditional into separate methods. 
	
	
2. what does it look like?
	Longer than 10 lines. It is hard to read and understand. It is trying to do more than one thing.
	Reuires a comment to explain what it is doing.

3. how does removing it improve reusability?
	Easier to understand and maintain so more likely to be reused by others or kept. 

4. what is the step by step to remove the bad smell?
	Extract method = 
		1. create new method with self evident name. 
		2. copy relevant code to new method, and delete from old, put a call to new method instead.
		3. pass any vars declare prior to extracted code as parameters of new method.
		4. return the value if required in main method.
		
	Replace method with method object =
		1. create a new class with good name
		2. In the new class create private field for storing reference to an instance of the class in which the method was previously located.
		3. create a separate private field for each local var of the method.
		4. Create a constructor to acceot as params the values of all local vars of the method and also initialises the corresponding private fields.
		5. Declare the main method and copy the code of the original to it, replacing the local variables with private fields.
		6. Replace the body of the original method in the original class by creating a method object and calling it's main method.
		
	Decompose conditional =
		1. Extract conditional to separate method via Extract Method.
		2. Repeat process for the then / else blocks.
		
*Large class
1. how do you know it is that bad smell, and how is it solved?
	- class contains many fields/methods/lines of code.
	- Trying to do too many different things, wearing too many hats.
	HOW TO SOLVE
	- Extract class (if part of behaviour can be put into different class)
	- Extract subclass (If parts of the class can be implemented in different ways or is used in rare cases)
	- Extract interface (if it is necessary to have a list of the operatings and behaviours that the client can use)

	
2. what does it look like?
	Large  class, hard to understand, fulfilling to many roles.


3. how does removing it improve reusability?
	Easier to read and understand, easier to maintain. Avoids duplication of code and functionality. 

4. what is the step by step to remove the bad smell?
	EXTRACT CLASS 
		1. Create a new class to contain relevant functionality
		2. Create relationship between old class and new.
		3. Move Field - 
			1. recreate the same field with access methods in new class
			2. Create a get method to get the field in both classes.
			3. Replace all references to the old field with calls to the methods in the new class.
			4. delete field in original class
		Move method - 
			1. verify all features used by old method in its class. May need to move them as well. And move any other methods that rely on the feature. Make sure method is not declared in superclasses or sub classes, if is don't move
			2. declare the new method in the recipient class, mayb ewith more appropriate name given its new location
			3. Make sure there ways to return the appropriate object. Turn old method into a reference to the new method.
			4. Can you delete the old method entirely? If so, place a reference to the new method in all places that use the old one
		After moving does class need renaming to increase clarity. 
		4. Consider whether you want the new class accessible publicly by the client or privately through the subclass.
		
		EXTRACT SUBCLASS=
		1. create new subclass from class of interest
		2. if you need additional data to create objects from subclass create constructor and add params to it. Call the constructors parent implementation
		3. Find all class to the constructor of the parent class. When functionalit yof the a subclass is necessary replace parent constructor with the subclass constructor.
		4. Move neccessary methods and fields from parent class to subclass via
			PUSH DOWN METHOD=
			1. declare method in a subclass and copy its code from the superclass
			2. Remove the method from the superclass.
			3. Find all place where the method is used and verify that it is called from the necessary subclass.
			PUSH DOWN FIELD=
			1. Declare field in all the necessary subclasses 
			2. Remove the field from the superclass
		Move methods first , so the field is accessible the whole time, first in parent class then after in the subclass itself after move is complete.
		5. Find old fields controlling choice of functionality and delte fields, and use polymorphism instead. eg: Car class had isElectricCar, and refuel() depends on it to determine whether to fill with gas or electricity. Instead isElectricCar is removed and instead Car and ElectricCar classes have their own implementations of refuel() method.
		EXTRACT INTERFACE=
		1. Create empty interface
		2. Declare common operations in the interface
		3. Decalre the nessary classes as implementing the interface
		4. Change type declarations in the client code to use the new interface.
	
*Primitive Obsession
1. how do you know it is that bad smell, and how is it solved?
	- Use of primatives instead of small objects for simpler tasks(eg: currency, ranges, special strings for phone numbers)
	- Use of constants for coding information (such as a constant USER_ADMN_ROLE = 1 for referring to users with admin rights)
	- Use of string constants as field names for use in data arrays.

	- If you have large variety of primative fields maybe logically group them into their own class and maybe move associated data into the class too. REPLACE DATA VALUE WITH OBJECT.
	- If the values of primative fields are used in method params then INTRODUCE PARAM OBJECT
	- If there are arrays among the vars use REPLACE ARRAY WITH OBJECT
	
2. what does it look like?
	Lots of strings or ints are set within a class instead of making small objects for them.


3. how does removing it improve reusability?
	Using objects make the code more flexible because the values can be changed easier.
	Better understandability and organisation of code. Operations on particular data are in the same place. No more guessing the reason for each constant.
	Easier to find duplication

4. what is the step by step to remove the bad smell?
	REPLACE DATA VALUE WITH OBJECT=
	1. Create new class and copy field and relevant getter to it. Create constructor that accepts the simple value of the field.
	2. In original class change field type to the new class.
	3. In the getter in the original class, invoke the getter of the associated object.
	4. In the setter create a new value object. May need to also create a new object in the constructor if initial values had been set there for the field previously. 
	
	INTRODUCE PARAM OBJECT=
	1. Create new class that will represent your group of params. Make it immutable.
	2. Inthe method you want to refactor use ADD PARAM=
		1. Set whether this method is defined in a superclass or subclasses, if so need to repeats for each place method is used.
		2. Create new method by copying the old one and add necessary param to it. Replace code for old method with a call to the new method. You can plug in any value to the new param.
		3. Find all references to the old method and replace them with references to the new method
		4. Delete old method. If part of an interface it cant be deleted but instead mark as "deprecated".
	In all method class pass the object created from old method params to this param.
	3. Now start deleting old params from the method one by one, replacing them in the code with fields of the param object. Test program after each replacement.
	4. When done see whether there is any point in moving a part of the method to a param object class. If so use Move method or extract method.
	
	REPLACE ARRAY WITH OBJECT=
	1. Create new class that will contain data from the array. Place array itself in the class as a public field.
	2. Create field for storing the object of this class in the original class. Dont forget to also create the object itself in the place where you initiated the data array.
	3. In new class create access methods one by one for each of the array elements. Give self explanatory names to show what they do. Also replace each use of array element with corresponding access method.
	4. For each element of the array create a private method in the class and then change the access methods so that they use this field instead of the array.
	5. Delete array
	
	
	
*Long Param List
1. how do you know it is that bad smell, and how is it solved?
	-More than 3 or 4 params for a method
	
	- If some of the params are just results of method calls of another object use REPLACE PARAM WITH METHOD CALL
	- Instead of passing a group of data received from another object as params, pass the object itself to the method using PRESERVE WHOLE OBJECT
	- If there are several unrelated data elements, sometimes you can merge them into a single param object uaing INTRODUCE PARAM OBJECT
	
2. what does it look like?
	Lots of params for a method or a class , more than 4.

3. how does removing it improve reusability?
	Code becomes shorter and more readable.
	May reveal duplicated code.

4. what is the step by step to remove the bad smell?
	REPLACE PARAM WITH METHOD CALL=
	1. Make sure the value getting code doesnt use params from the current method since they will become unavailable from inside another method. If so cant move code.
	2. If relevant code to complicated for a single method use EXTRACT METHOD to isolate code in new method and make the call simple/
	3. in main method replace all referencces to the param being replaced with calls to the method that get sthe value
	4. Use REMOVE PARAM to eliminate now unused param=
		1. see if method defined in superclass or subclass. If param is used dont refactor using this.
		2. Create new method by copying old one and delete relevant param from it. Replace code with of old method with a call to the new one.
		3. Find all references to old method and replace them with references to the new method.
		4. Delete the old method. Dont perform this if old method is part of a public interface, just marks as deprecated.
		
	PRESERVE WHOLE OBJECT= 
	1. Create param in the method for the object from which you can get the necessary values
	2. Now start removing the old params from the method one by one, replacing them with calls to the relevant methods of the param object.
	3. Delete the getter code from the param object that had preceded the method call.
	
		INTRODUCE PARAM OBJECT=
	1. Create new class that will represent your group of params. Make it immutable.
	2. Inthe method you want to refactor use ADD PARAM=
		1. Set whether this method is defined in a superclass or subclasses, if so need to repeats for each place method is used.
		2. Create new method by copying the old one and add necessary param to it. Replace code for old method with a call to the new method. You can plug in any value to the new param.
		3. Find all references to the old method and replace them with references to the new method
		4. Delete old method. If part of an interface it cant be deleted but instead mark as "deprecated".
	In all method class pass the object created from old method params to this param.
	3. Now start deleting old params from the method one by one, replacing them in the code with fields of the param object. Test program after each replacement.
	4. When done see whether there is any point in moving a part of the method to a param object class. If so use Move method or extract method.
	
	
	

*Data Clumps
1. how do you know it is that bad smell, and how is it solved?
	- Differne tparts of the code contain identical groups of vars (such as params for connecting to db). These clumps should be turned into their own classes.
	
	- If repeating data comprises fields of a class, use EXTRACT CLASS.
	- If the same data clumps are passed in the params of methods use INTRODUCE PARAM OBJECT
	- If some of the data is passed to other methods think about passing the entire data object to the method instead of just individual fields, use PRESERVE WHOLE OBJECT
	- Look at the code used by these fields. It may be a good idea to move the code to a data class.
	
2. what does it look like?
	Identical data chucks in different places throughout the code.
	Copy and pasted data

3. how does removing it improve reusability?
	Improves understanding and organisation  of code. Particular data operations are in the same place. 
	Centralises the code, less problems with inconsistency.
	Reduces code size.

4. what is the step by step to remove the bad smell?
	EXTRACTT CLASS 
		1. Create a new class to contain relevant functionality
		2. Create relationship between old class and new.
		3. Move Field - 
			1. recreate the same field with access methods in new class
			2. Create a get method to get the field in both classes.
			3. Replace all references to the old field with calls to the methods in the new class.
			4. delete field in original class
		Move method - 
			1. verify all features used by old method in its class. May need to move them as well. And move any other methods that rely on the feature. Make sure method is not declared in superclasses or sub classes, if is don't move
			2. declare the new method in the recipient class, mayb ewith more appropriate name given its new location
			3. Make sure there ways to return the appropriate object. Turn old method into a reference to the new method.
			4. Can you delete the old method entirely? If so, place a reference to the new method in all places that use the old one
		After moving does class need renaming to increase clarity. 
		4. Consider whether you want the new class accessible publicly by the client or privately through the subclass.
		
	INTRODUCE PARAM OBJECT=
	1. Create new class that will represent your group of params. Make it immutable.
	2. Inthe method you want to refactor use ADD PARAM=
		1. Set whether this method is defined in a superclass or subclasses, if so need to repeats for each place method is used.
		2. Create new method by copying the old one and add necessary param to it. Replace code for old method with a call to the new method. You can plug in any value to the new param.
		3. Find all references to the old method and replace them with references to the new method
		4. Delete old method. If part of an interface it cant be deleted but instead mark as "deprecated".
	In all method class pass the object created from old method params to this param.
	3. Now start deleting old params from the method one by one, replacing them in the code with fields of the param object. Test program after each replacement.
	4. When done see whether there is any point in moving a part of the method to a param object class. If so use Move method or extract method.
	
		PRESERVE WHOLE OBJECT= 
	1. Create param in the method for the object from which you can get the necessary values
	2. Now start removing the old params from the method one by one, replacing them with calls to the relevant methods of the param object.
	3. Delete the getter code from the param object that had preceded the method call.

***Object-Orientation Abusers***
*Switch Statements
1. how do you know it is that bad smell, and how is it solved?
	- Complex if/else 's or switch statments
	
	- To isolate switch and put in right code EXTRACT METHOD and then MOVE METHOD
	- If switch is based on TypeCode then REPLACE TYPE CODE WITH STRATEGY
	- After specifying inheritance structure use REPLACE CONDITIONAL WITH POLYMORPHISM
	- If too many conditionals and all call same method with different params, break method int omultiple smaller methods with REPLACE PARAM WITH EXPLICIT METHODS
	- if one of the conditional opitions is null use INTRODUCE NULL OBJECT
	
2. what does it look like?
	Complex switch or if statements

3. how does removing it improve reusability?
	Improve code organisation.
	Easier to follow what the code is doing.
	
	but ignore switch or if where it is doing simple things, or where it is reuired by a factory design pattern.

4. what is the step by step to remove the bad smell?

	Extract method = 
		1. create new method with self evident name. 
		2. copy relevant code to new method, and delete from old, put a call to new method instead.
		3. pass any vars declare prior to extracted code as parameters of new method.
		4. return the value if required in main method.
	Move method - 
		1. verify all features used by old method in its class. May need to move them as well. And move any other methods that rely on the feature. Make sure method is not declared in superclasses or sub classes, if is don't move
		2. declare the new method in the recipient class, mayb ewith more appropriate name given its new location
		3. Make sure there ways to return the appropriate object. Turn old method into a reference to the new method.
		4. Can you delete the old method entirely? If so, place a reference to the new method in all places that use the old one
		
	REPLACE CODE WITH STRATEGY=
	1. use SELF ENCAPSULATE FIELD to create a getter for the field that contains the type code=
		1. create a getter (maybe setter) for the field. 
		2. Find all direct invocations of the field and replace them with getter and setter calls
	2. Create new class with good name. This will be strategy class. In it create an abstract coded field getter.
	3. Create subclass of te strategy class for each value of the coded type. In each subclass redefine the getter of the coded field so that it returns the corresponding value of the the coded type.
	4. In abstract strategy class create a static factory method that accepts the value of the coded type as a param. Depending on the param the factory method will create objects of various strategies. This will have a conditional.
	5. In the original class change the type of the coded field to the state class. In the fields setter call the factory strategy method for getting new strategy objects.
	6. Now you can start to move the fields and methods from superclass down, using PUSH DOWN METHOD AND PUSH DOWN FIELD
				PUSH DOWN METHOD=
			1. declare method in a subclass and copy its code from the superclass
			2. Remove the method from the superclass.
			3. Find all place where the method is used and verify that it is called from the necessary subclass.
			PUSH DOWN FIELD=
			1. Declare field in all the necessary subclasses 
			2. Remove the field from the superclass
	7. When everything moveable has been moved use REPLACE CONDITIONAL WITH POLYMORPHISM=
		1. If the conditional is a method that performs other actions as well perform EXTRACT METHOD=		
			1. create new method with self evident name. 
			2. copy relevant code to new method, and delete from old, put a call to new method instead.
			3. pass any vars declare prior to extracted code as parameters of new method.
			4. return the value if required in main method.
		2. For each hierarchy subclass, redefine the method that contains the conditional and copy the code of the corresponding conditional branch to that location.
		3. Delete that branch from the conditional.
		4. Repeat replacement until all conditional empty, then delete conditional and  declare method abstract.
		
		REPLACE PARAM WITH EXPLICIT METHODS=
		1. for each variant of the method create a separate method. Run these methods based on the value of a param in the main method.
		2. Find all the places the original method is called. In these places place a call for one of the new param dependant variants.
		3. when no calls to the original method remain, delete it.
		
		INTRODUCE NULL OBJECT=
		1. From the class in question create a subclass that will perform the role of null object.
		2. In both classes create the method isNull() which will return true for null object, false for real class
		3. find all places where the code may return null instead of a real object. Change the code so it returns a null object.
		4. find all places where the vars of the real class are compared with null. Replace these checks with a call for isNull().
		5. If methods of the original class are run in these conditionals when a value does not equal null redefine these methods in the null class and insert the code from the else part of the condition there. Then you can delete the entire conditional and differing behaviour will be implemented via polymorphism.

		
*Temporary Field
1. how do you know it is that bad smell, and how is it solved?
	- Temporary fields get their value only under certain circumstances, otherwise they sit empty.
	
	- Temporary fields and code using them can be put into their own class via EXTRACT CLASS.
	- INTRODUCE NULL OBJECT and integrate it in place of the conditional code which was used to check the temporary field values for existence.
	
2. what does it look like?
	Fields in a class or method are only used some of the time. Sit empty and unused mostly.

3. how does removing it improve reusability?
	Better code clarity and understanding.
	Easier to read.
	More efficiency
	More focussed code.

4. what is the step by step to remove the bad smell?

	EXTRACT CLASS 
		1. Create a new class to contain relevant functionality
		2. Create relationship between old class and new.
		3. Move Field - 
			1. recreate the same field with access methods in new class
			2. Create a get method to get the field in both classes.
			3. Replace all references to the old field with calls to the methods in the new class.
			4. delete field in original class
		Move method - 
			1. verify all features used by old method in its class. May need to move them as well. And move any other methods that rely on the feature. Make sure method is not declared in superclasses or sub classes, if is don't move
			2. declare the new method in the recipient class, mayb ewith more appropriate name given its new location
			3. Make sure there ways to return the appropriate object. Turn old method into a reference to the new method.
			4. Can you delete the old method entirely? If so, place a reference to the new method in all places that use the old one
		After moving does class need renaming to increase clarity. 
		4. Consider whether you want the new class accessible publicly by the client or privately through the subclass.
		
		INTRODUCE NULL OBJECT=
		1. From the class in question create a subclass that will perform the role of null object.
		2. In both classes create the method isNull() which will return true for null object, false for real class
		3. find all places where the code may return null instead of a real object. Change the code so it returns a null object.
		4. find all places where the vars of the real class are compared with null. Replace these checks with a call for isNull().
		5. If methods of the original class are run in these conditionals when a value does not equal null redefine these methods in the null class and insert the code from the else part of the condition there. Then you can delete the entire conditional and differing behaviour will be implemented via polymorphism.

*Refused bequest
1. how do you know it is that bad smell, and how is it solved?
	- a subclass only uses some of its methods and properties inherited from its parents.
	
	- if inheritance makes no sense and the subclass has nothing in common with the superclass REPLACE INHERITANCE WITH DELEGATION
	- if inheritance is appropriate, get rid of unneeded fields and methods in the subclass. Extract all fields and methods needed by the subclass from the parent class, put them in a new subclass and set both classes to inherit from it using EXTRACT SUPERCLASS.

	
2. what does it look like?
	Some methods and or properties from parent class get unused by a subclass. 


3. how does removing it improve reusability?
	Improves code clarity and organisation

4. what is the step by step to remove the bad smell?
	REPLACE INHERITANCE WITH DELEGATION=
	1. create a field in the subclass for holding the superclass. During the initial stage place the current object in it.
	2. Change the subclass methods so thst they use the superclass object instead of "this"
	3. for methods inherited from the superclas that are called in client code create simple delegating methods in the subclass
	4. remove the inheritance declaration from the subclass
	5. Chnage the initialisation code o the field in which the former superclass is stored by creating a new object.
	
	EXTRACT SUPERCLASS=
	1. create an abstract superclass
	2. use PULL UP FIELD=
		1. make sure the fields are used fo the same needs in subclasses
		2. if the fields have different names give them the same name and replace all references to the fields in existing code.
		3. create a field with the same name in the superclass. Note that if the fields were private, the superclass field should be protected.
		4. remove the fields from the subclasses
	use PULL UP METHOD=
		1. investigate similar methods in superclasses. if not identical tformat  then to match each other.
		2. if methods use a different set of params put the params in the form that you want to see in the superclass
		3. copy the method to the superclass. here you may find that the method code uses fields and methods that exist only in subclasses and therefore are not available in the superclass. To solve this PULL UP FIELD to create getters and setters in the subclasses, then declare these getters abstractly in the superclass, or use PULL UP METHOD
		4. Remove the methods from the subclasses
		5. check the locations in which the method is called. in some places you may be able to replace use of a subclass with the superclass.
	use PULL UP CONSTRUCTOR BODY=
		1. create constructor in a superclass
		2. Extract common code from the beginning of the constructor of each subclass to the superclass constructor. Before doing so try to move as much common code as possible to the beginning to the constructor.
		3. Place the call for the superclass constructor in the first line in the subclass constructors.
	to move the common functionality to a superclass. Start with the fields, since in addition to the common fields you will need to move the fields that are used in the common methods.
	3. Look for places in the client code where use of subclass can be replaced with your new class (such as in type declarations)
	

	
*Alternative Class with Different Interfaces
1. how do you know it is that bad smell, and how is it solved?
	- 2 classes perform identical functions but have different method names
	
	- RENAME METHODS to make them identical in all alternative classes.
	- to make the signature and implementation of methods the same MOVE METHOD, ADD PARAM, and PARAMETERISE METHOD.
	- if only part of the funcationality of the classes is duplicated try using EXTRACT SUPERCLASS. In this case the existing classes will become subclasses.
	
2. what does it look like?
	Identical functions in multiple classes have different names.

3. how does removing it improve reusability?
	Get rid of unnecessary duplicated code. Code is then less bulky.
	Code more readable. No longer need to guess the reason for 2 classes performing the same functions.

4. what is the step by step to remove the bad smell?
	RENAME METHOD=
	1. See whether method defined in a superclass or subclass. If so repeat these step for all.
	2. Create a new method with a new name. copy the code of the old method to it. Delete all the code in the old method, and instead of it, insert a call for the new method.
	3. Find all references to the old method and replace them with references to the new one.
	4. delete the old method. If the old method is part of a public interface, instead just mark it as deprecated and leave it.
	
	Move method - 
	1. verify all features used by old method in its class. May need to move them as well. And move any other methods that rely on the feature. Make sure method is not declared in superclasses or sub classes, if is don't move
	2. declare the new method in the recipient class, mayb ewith more appropriate name given its new location
	3. Make sure there ways to return the appropriate object. Turn old method into a reference to the new method.
	4. Can you delete the old method entirely? If so, place a reference to the new method in all places that use the old one
	
	 ADD PARAM=
	1. Set whether this method is defined in a superclass or subclasses, if so need to repeats for each place method is used.
	2. Create new method by copying the old one and add necessary param to it. Replace code for old method with a call to the new method. You can plug in any value to the new param.
	3. Find all references to the old method and replace them with references to the new method
	4. Delete old method. If part of an interface it cant be deleted but instead mark as "deprecated".
	
	PARAMETERISE METHOD=
	1. Create a new method with a parameter and move it to the code that is the same for all classes by appling 	Extract method = 
		1. create new method with self evident name. 
		2. copy relevant code to new method, and delete from old, put a call to new method instead.
		3. pass any vars declare prior to extracted code as parameters of new method.
		4. return the value if required in main method.
	2. in the code of the new method replace the special different value with a param.
	3. For each old method , find the places where it is called, replacing these calls with calls  to the new method that include a param. Then delete the old method.
	
	EXTRACT SUPERCLASS=
	1. create an abstract superclass
	2. use PULL UP FIELD=
		1. make sure the fields are used fo the same needs in subclasses
		2. if the fields have different names give them the same name and replace all references to the fields in existing code.
		3. create a field with the same name in the superclass. Note that if the fields were private, the superclass field should be protected.
		4. remove the fields from the subclasses
	use PULL UP METHOD=
		1. investigate similar methods in superclasses. if not identical tformat  then to match each other.
		2. if methods use a different set of params put the params in the form that you want to see in the superclass
		3. copy the method to the superclass. here you may find that the method code uses fields and methods that exist only in subclasses and therefore are not available in the superclass. To solve this PULL UP FIELD to create getters and setters in the subclasses, then declare these getters abstractly in the superclass, or use PULL UP METHOD
		4. Remove the methods from the subclasses
		5. check the locations in which the method is called. in some places you may be able to replace use of a subclass with the superclass.
	use PULL UP CONSTRUCTOR BODY=
		1. create constructor in a superclass
		2. Extract common code from the beginning of the constructor of each subclass to the superclass constructor. Before doing so try to move as much common code as possible to the beginning to the constructor.
		3. Place the call for the superclass constructor in the first line in the subclass constructors.
	to move the common functionality to a superclass. Start with the fields, since in addition to the common fields you will need to move the fields that are used in the common methods.
	3. Look for places in the client code where use of subclass can be replaced with your new class (such as in type declarations)
	

***Change Preventers***
*Divergent Change
1. how do you know it is that bad smell, and how is it solved?
	- You find yourself having to change many unrelated methods when you make changes to a class. eg: when adding a new product type you need to change methods for finding,, displaying and ordering products.
	
	- split up behaviour of a class via EXTRACT CLASS
	- if different classes have the same same behaviour, you may want to combine the classes through inheritance using EXTRACT SUPERCLASS or EXTRACT SUBCLASS
	
2. what does it look like?
	Have to make changes to methods all over the place when changing a class. Not properly decoupled.

3. how does removing it improve reusability?
	easiier to add and maintain. 
	more modular for future use.
	improves code organisation.

4. what is the step by step to remove the bad smell?
EXTRACT CLASS 
		1. Create a new class to contain relevant functionality
		2. Create relationship between old class and new.
		3. Move Field - 
			1. recreate the same field with access methods in new class
			2. Create a get method to get the field in both classes.
			3. Replace all references to the old field with calls to the methods in the new class.
			4. delete field in original class
		Move method - 
			1. verify all features used by old method in its class. May need to move them as well. And move any other methods that rely on the feature. Make sure method is not declared in superclasses or sub classes, if is don't move
			2. declare the new method in the recipient class, mayb ewith more appropriate name given its new location
			3. Make sure there ways to return the appropriate object. Turn old method into a reference to the new method.
			4. Can you delete the old method entirely? If so, place a reference to the new method in all places that use the old one
		After moving does class need renaming to increase clarity. 
		4. Consider whether you want the new class accessible publicly by the client or privately through the subclass.
	
	EXTRACT SUPERCLASS=
	1. create an abstract superclass
	2. use PULL UP FIELD=
		1. make sure the fields are used fo the same needs in subclasses
		2. if the fields have different names give them the same name and replace all references to the fields in existing code.
		3. create a field with the same name in the superclass. Note that if the fields were private, the superclass field should be protected.
		4. remove the fields from the subclasses
	use PULL UP METHOD=
		1. investigate similar methods in superclasses. if not identical tformat  then to match each other.
		2. if methods use a different set of params put the params in the form that you want to see in the superclass
		3. copy the method to the superclass. here you may find that the method code uses fields and methods that exist only in subclasses and therefore are not available in the superclass. To solve this PULL UP FIELD to create getters and setters in the subclasses, then declare these getters abstractly in the superclass, or use PULL UP METHOD
		4. Remove the methods from the subclasses
		5. check the locations in which the method is called. in some places you may be able to replace use of a subclass with the superclass.
	use PULL UP CONSTRUCTOR BODY=
		1. create constructor in a superclass
		2. Extract common code from the beginning of the constructor of each subclass to the superclass constructor. Before doing so try to move as much common code as possible to the beginning to the constructor.
		3. Place the call for the superclass constructor in the first line in the subclass constructors.
	to move the common functionality to a superclass. Start with the fields, since in addition to the common fields you will need to move the fields that are used in the common methods.
	3. Look for places in the client code where use of subclass can be replaced with your new class (such as in type declarations)
	
	EXTRACT SUBCLASS=
		1. create new subclass from class of interest
		2. if you need additional data to create objects from subclass create constructor and add params to it. Call the constructors parent implementation
		3. Find all class to the constructor of the parent class. When functionalit yof the a subclass is necessary replace parent constructor with the subclass constructor.
		4. Move neccessary methods and fields from parent class to subclass via
			PUSH DOWN METHOD=
			1. declare method in a subclass and copy its code from the superclass
			2. Remove the method from the superclass.
			3. Find all place where the method is used and verify that it is called from the necessary subclass.
			PUSH DOWN FIELD=
			1. Declare field in all the necessary subclasses 
			2. Remove the field from the superclass
		Move methods first , so the field is accessible the whole time, first in parent class then after in the subclass itself after move is complete.
		5. Find old fields controlling choice of functionality and delte fields, and use polymorphism instead. eg: Car class had isElectricCar, and refuel() depends on it to determine whether to fill with gas or electricity. Instead isElectricCar is removed and instead Car and ElectricCar classes have their own implementations of refuel() method.
		EXTRACT INTERFACE=
		1. Create empty interface
		2. Declare common operations in the interface
		3. Decalre the nessary classes as implementing the interface
		4. Change type declarations in the client code to use the new interface.
		
	

*Shotgun Surgery
1. how do you know it is that bad smell, and how is it solved?
	- making any small modifications reuires making small canges to many different classes. A single responsibility has been split up between a large number of classes.
	
	- use MOVE METHOD or MOVE FIELD to move existing class behaviour into a single class. If there is no class appropriate for this, create one.
	- if moving code to the same class leaves the original classes almost empty, try to get rid of these redundant classes via INLINE CLASS. 
	
2. what does it look like?
	Single responsibility has been split between many classes. Overzealous treatment of Divergent Chnage.

3. how does removing it improve reusability?
	easier to maintain because the code is simpler to change. dont need to make changes all over the place.

4. what is the step by step to remove the bad smell?
	Move Field - 
			1. recreate the same field with access methods in new class
			2. Create a get method to get the field in both classes.
			3. Replace all references to the old field with calls to the methods in the new class.
			4. delete field in original class
		Move method - 
			1. verify all features used by old method in its class. May need to move them as well. And move any other methods that rely on the feature. Make sure method is not declared in superclasses or sub classes, if is don't move
			2. declare the new method in the recipient class, mayb ewith more appropriate name given its new location
			3. Make sure there ways to return the appropriate object. Turn old method into a reference to the new method.
			4. Can you delete the old method entirely? If so, place a reference to the new method in all places that use the old one
	
	INLINE CLASS=
	1. in recipient class create the public fields and methods present in the donor class. Methods should refer to the equivalentmethods of the donor class.
	2. replace all references to the donor class references to the fields and methods of the recipient class.
	3. Now test the program and make sure that no errors have been added. If tests show that everything is working A-OK, start using MOVE METHOD and MOVE FIELD to completely transplant all functionality to the recipient class from the original one. Continue until original class is empty.
	4. Delete original class.
			

*Parallel Inheritance Hierarchies
1. how do you know it is that bad smell, and how is it solved?
	- Whenever creating a subclass you find yourself having to create a subclass for another class.
	
	- May de-duplicate paralle class hierarchies in 2 steps. 1st make instances of one hierarchy refer to instances of another hierarchy. Then remove the hierarchy in the reffered class by using MOVE METHOD and MOVE FIELD

	
2. what does it look like?
	cant just change add a subclass in one place, forced to subclass elsewhere. Look at folding the parallel hierarchies into one.

3. how does removing it improve reusability?
	improves maintainability and readability

4. what is the step by step to remove the bad smell?
	Move Field - 
			1. recreate the same field with access methods in new class
			2. Create a get method to get the field in both classes.
			3. Replace all references to the old field with calls to the methods in the new class.
			4. delete field in original class
		Move method - 
			1. verify all features used by old method in its class. May need to move them as well. And move any other methods that rely on the feature. Make sure method is not declared in superclasses or sub classes, if is don't move
			2. declare the new method in the recipient class, mayb ewith more appropriate name given its new location
			3. Make sure there ways to return the appropriate object. Turn old method into a reference to the new method.
			4. Can you delete the old method entirely? If so, place a reference to the new method in all places that use the old one

***Dispensibles***
*Comments
1. how do you know it is that bad smell, and how is it solved?

	
2. what does it look like?


3. how does removing it improve reusability?


4. what is the step by step to remove the bad smell?

*Duplicate Code
1. how do you know it is that bad smell, and how is it solved?

	
2. what does it look like?


3. how does removing it improve reusability?


4. what is the step by step to remove the bad smell?

*Lazy Class
1. how do you know it is that bad smell, and how is it solved?

	
2. what does it look like?


3. how does removing it improve reusability?


4. what is the step by step to remove the bad smell?

*Data Class
1. how do you know it is that bad smell, and how is it solved?

	
2. what does it look like?


3. how does removing it improve reusability?


4. what is the step by step to remove the bad smell?

*Dead Code
1. how do you know it is that bad smell, and how is it solved?

	
2. what does it look like?


3. how does removing it improve reusability?


4. what is the step by step to remove the bad smell?

*Speculative Granularity
1. how do you know it is that bad smell, and how is it solved?

	
2. what does it look like?


3. how does removing it improve reusability?


4. what is the step by step to remove the bad smell?

***Couplers***
*Feature Envy
1. how do you know it is that bad smell, and how is it solved?

	
2. what does it look like?


3. how does removing it improve reusability?


4. what is the step by step to remove the bad smell?

*Inappropriate Intimacy
1. how do you know it is that bad smell, and how is it solved?

	
2. what does it look like?


3. how does removing it improve reusability?


4. what is the step by step to remove the bad smell?

*Message chains
1. how do you know it is that bad smell, and how is it solved?

	
2. what does it look like?


3. how does removing it improve reusability?


4. what is the step by step to remove the bad smell?

*Middleman
1. how do you know it is that bad smell, and how is it solved?

	
2. what does it look like?


3. how does removing it improve reusability?


4. what is the step by step to remove the bad smell?

*Incomplete Library Class1. how do you know it is that bad smell, and how is it solved?

	
2. what does it look like?


3. how does removing it improve reusability?


4. what is the step by step to remove the bad smell?